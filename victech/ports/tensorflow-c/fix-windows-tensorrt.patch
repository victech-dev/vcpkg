diff --git a/tensorflow/compiler/tf2tensorrt/convert/convert_nodes.cc b/tensorflow/compiler/tf2tensorrt/convert/convert_nodes.cc
index 96cec556..36d817db 100644
--- a/tensorflow/compiler/tf2tensorrt/convert/convert_nodes.cc
+++ b/tensorflow/compiler/tf2tensorrt/convert/convert_nodes.cc
@@ -355,7 +355,7 @@ Status GetTrtBroadcastShape(const TRT_TensorOrWeights& operand_l,
   }
 
   const int max_nb_dims = nvinfer1::Dims::MAX_DIMS + 1;
-  auto compute_output_dims = [use_implicit_batch](
+  auto compute_output_dims = [use_implicit_batch, max_nb_dims](
                                  const TRT_TensorOrWeights& input,
                                  int broadcast_num_dims, int* output_dims_array,
                                  nvinfer1::Dims* output_dims) {
@@ -4752,12 +4752,13 @@ Status ConvertSplit(OpConverterParams* params) {
   const auto& node_def = params->node_def;
   TF_RETURN_IF_ERROR(
       CheckInputsWeights(*params, {{"axis", true}, {"value", false}}));
-  TF_RETURN_IF_ERROR(AllowDataTypes(*params, {
+  std::set<DataType> allowDataTypes = {
     DataType::DT_FLOAT, DataType::DT_HALF,
 #if IS_TRT_VERSION_GE(5, 1, 3, 1)
         DataType::DT_INT32,
 #endif
-  }));
+  };
+  TF_RETURN_IF_ERROR(AllowDataTypes(*params, allowDataTypes));
   int tf_axis = inputs.at(0).weights().GetSpan<int>()[0];
   TFAttrs attrs(node_def);
   const int num_split = attrs.get<int64>("num_split");
@@ -4769,12 +4770,13 @@ Status ConvertUnpack(OpConverterParams* params) {
   const auto& inputs = params->inputs;
   const auto& node_def = params->node_def;
   TF_RETURN_IF_ERROR(CheckInputsWeights(*params, {{"value", false}}));
-  TF_RETURN_IF_ERROR(AllowDataTypes(*params, {
+  std::set<DataType> allowDataTypes = {
     DataType::DT_FLOAT, DataType::DT_HALF,
 #if IS_TRT_VERSION_GE(5, 1, 3, 1)
         DataType::DT_INT32,
 #endif
-  }));
+  };
+  TF_RETURN_IF_ERROR(AllowDataTypes(*params, allowDataTypes));
   // Input must be rank 1 or higher, since we can't unpack on axis 0.
   if (inputs.at(0).GetTrtDims().nbDims == 0) {
     return errors::Unimplemented(
diff --git a/tensorflow/compiler/tf2tensorrt/segment/segment.cc b/tensorflow/compiler/tf2tensorrt/segment/segment.cc
index 32e30006..be0d57db 100644
--- a/tensorflow/compiler/tf2tensorrt/segment/segment.cc
+++ b/tensorflow/compiler/tf2tensorrt/segment/segment.cc
@@ -263,8 +263,7 @@ void StableDFS(const SimpleGraph& g, bool reverse,
     stack[i] = Work{start[i], false};
   }
 
-  auto get_nodes = reverse ? [](const SimpleNode* n) { return n->in_nodes(); }
-                           : [](const SimpleNode* n) { return n->out_nodes(); };
+  auto get_nodes = [reverse](const SimpleNode* n) { return reverse ? n->in_nodes() : n->out_nodes(); };
   std::vector<bool> visited(g.num_node_ids(), false);
   while (!stack.empty()) {
     Work w = stack.back();
diff --git a/tensorflow/tensorflow.bzl b/tensorflow/tensorflow.bzl
index 3ba217c4..2fc8dc02 100644
--- a/tensorflow/tensorflow.bzl
+++ b/tensorflow/tensorflow.bzl
@@ -1796,7 +1796,7 @@ def tf_custom_op_library_additional_deps():
         "@com_google_protobuf//:protobuf_headers",
         clean_dep("//third_party/eigen3"),
         clean_dep("//tensorflow/core:framework_headers_lib"),
-    ] + if_windows([clean_dep("//tensorflow/python:pywrap_tensorflow_import_lib")])
+    ]
 
 # A list of targets that contains the implemenation of
 # tf_custom_op_library_additional_deps. It's used to generate a DEF file for
